// grafi con archi a peso uguale -> dijkstra; poi di tutti trovi quello accettabile
// oppure BFS (visita in ampiezza)

// BST?
// RBT?
// forse le stazioni per i veicoli fai direttamente vettore[512]
// #include <stdint.h>   int32_t
// per memorizzare numeri grandi basta int, se devo farci operazioni no

// usare un max heap per le macchine nelle stazioni, cosÃ¬ ho il massimo con vehicles->autonomy[0]

int last_index = path_dim - 1;
    for (int i = path_dim - 2; i > 0; i--) {
        int temp_index = last_index;

        if (path[i - 1].distancePlusMax <= path[last_index].distance) {
            while (path[i - 1].distancePlusMax <= path[temp_index].distance && temp_index < path_dim) {
                int k = temp_index;
                while (path[k - 1].distance == -1) {
                    k--;
                }
                path[k - 1].distance = -1;
                temp_index++;
            }
            last_index = temp_index - 1;
        } else {
            last_index = i;
        }
    }





    int last_index = path_dim - 1;
        for (int i = path_dim - 2; i > 0; i--) {
            printf("%d -> %d > %d\n", path[i - 1].distance, path[i - 1].distancePlusMax, path[last_index].distance);
            if (path[i - 1].distancePlusMax > path[last_index].distance) {
                last_index--;
                continue;
            }
            int k = 0;
            printf("%d <= %d\n", path[i - 1 - k].distancePlusMax, path[last_index].distance);
            while (path[i - 1 - k].distancePlusMax <= path[last_index].distance) {
                k++;
                printf("%d <= %d\n", path[i - 1 - k].distancePlusMax, path[last_index].distance);
            }
            printf("%d\n", k);

            // I'll remove k elements from the array, in particular every i - 2*t
            for (int t = k - 1; t >= 0; t--) {
                for (int j = i - 2 * t; j < path_dim - 1; j++) {
                    path[j].distance = path[j + 1].distance;
                    path[j].distancePlusMax = path[j + 1].distancePlusMax;
                }
                path_dim--;
                for (int z = 0; z < path_dim; z++) {
                    printf("%d ", path[z].distance);
                }
                printf("\n");
            }
        }







        int last_index = path_dim - 1;
            for (int i = path_dim - 2; i > 0; i--) {
                if (path[i - 1].distancePlusMax > path[last_index].distance) { //
                    last_index--;
                    continue;
                }

                if (i == 1) {
                    // I delete the i-element in path
                    for (int j = i; j < path_dim - 1; j++) {
                        path[j] = path[j + 1];
                    }
                    path_dim--;
                    continue;
                }

                // If I get here, it means path[i - 1].distancePlusMax <= path[last_index].distance
                if (path[i - 2].distancePlusMax > path[last_index].distance) {
                    // I delete the i-element in path
                    for (int j = i; j < path_dim - 1; j++) {
                        path[j] = path[j + 1];
                    }
                    path_dim--;

                    i++;
                    continue;
                }

                if (path[i - 3].distancePlusMax > path[last_index].distance) {
                    // I delete the i-element in path
                    for (int j = i; j < path_dim - 1; j++) {
                        path[j] = path[j + 1];
                    }
                    path_dim--;
                    last_index--;

                    // Check if I can delete the (i-2)-element in path too
                    if (path[i - 3].distancePlusMax <= path[i - 1].distance) {
                        for (int j = i - 2; j < path_dim - 1; j++) {
                            path[j] = path[j + 1];
                        }
                        path_dim--;
                    }
                    continue;
                }

                if (path[i - 4].distancePlusMax > path[last_index].distance) {
                    // I delete the i-element in path
                    for (int j = i; j < path_dim - 1; j++) {
                        path[j] = path[j + 1];
                    }
                    path_dim--;
                    last_index--;

                    if (path[i - 4].distancePlusMax <= path[i - 1].distance) {
                        for (int j = i - 3; j < path_dim - 2; j++) {
                            path[j] = path[j + 2];
                        }
                        path_dim-=2;
                    } else if (path[i - 4].distancePlusMax <= path[i - 2].distance) {
                        for (int j = i - 3; j < path_dim - 1; j++) {
                            path[j] = path[j + 1];
                        }
                        path_dim--;
                    }
                }











                dritto


                int last_distance = path[path_dim - 1].distance;
                    for (int i = path_dim - 2; i > 0; i--) {
                        if (path[i - 1].distancePlusMax >= last_distance) {
                            path[i].distance = -1;
                        } else {
                            last_distance = path[i].distance;
                        }
                    }










                    // region print
                    void printHeap(Vehicles *v) {
                        for (int i = 0; i < v->num_vehicles; i++) {
                            printf("%d ", v->autonomy[i]);
                        }
                        printf("\n");
                    }

                    void printGraph(Highway *highway) {
                        for (int i = 0; i < highway->num_stations; i++) {
                            printf("Station: %d km, %d veicoli, veicoli: ", highway->stations[i].distance,
                                   highway->stations[i].cars->num_vehicles);
                            printHeap(highway->stations[i].cars);
                        }
                    }
                    // endregion print



int *true_path = (int *) malloc(sizeof(int) * (start_index - target_index + 1));
    true_path[0] = path[0].distance;
    int true_dim = 1;

    int end_reached = 0;
    for (int i = 0; i < path_dim; i++) {
        int j = i + 1;
        while (path[i].distancePlusMax <= path[j].distance && j < path_dim) {
            if (path[j].distance == target) {
                true_path[true_dim] = target;
                true_dim++;
                end_reached = 1;
                break;
            }
            j++;
        }

        if (end_reached == 1) {
            break;
        }

        int k = j - 1;
        if (k == i) {
            // I only have one possible path, keep going
            true_path[true_dim] = path[k].distance;
            true_dim++;
            continue;
        }

        while (path[k].distancePlusMax > path[j].distance && k > 0) {
            k--;
        }

        if (path[k].distancePlusMax <= path[j].distance) {
            true_path[true_dim] = path[k].distance;
            true_dim++;
        } else {
            printf("nessun percorso\n"); // shouldn't be possible, it's a precaution
            return;
        }

        // now I want to move i to the k position, however with the for loop i is going to increase by one, so now
        // I'll set it to k - 1
        i = k - 1;
    }

    for (int i = 0; i < true_dim - 1; i++) {
        if (true_path[i]) {
            printf("%d ", true_path[i]);
        }
    }
    printf("%d\n", true_path[true_dim]);

    free(true_path);
    free(path);